import streamlit as st
import pandas as pd
import re
import base64
from datetime import datetime
import io
from io import StringIO

# Configuration
st.set_page_config(page_title="üîÆ LOOPY DIOD Pro", layout="wide")

# CSS optimis√©
st.markdown("""
<style>
    .main-header {
        text-align: center;
        padding: 2rem;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 20px;
        margin-bottom: 2rem;
        color: white;
    }
    .stButton>button {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        border: none;
        border-radius: 10px;
        padding: 10px 20px;
        font-weight: bold;
    }
    .classification-badge {
        display: inline-block;
        padding: 4px 12px;
        border-radius: 15px;
        font-size: 12px;
        font-weight: bold;
        margin: 2px;
    }
</style>
""", unsafe_allow_html=True)

# SYST√àME DE CLASSIFICATION INTELLIGENT
CLASSIFICATION_RULES = {
    "üìû T√©l√©phones Ha√Øti": {
        "patterns": [r'^509', r'^\+509'],
        "color": "#FF6B6B"
    },
    "üìû T√©l√©phones France": {
        "patterns": [r'^33', r'^\+33', r'^0033'],
        "color": "#4ECDC4"
    },
    "üìû T√©l√©phones USA/Canada": {
        "patterns": [r'^1', r'^\+1', r'^001'],
        "color": "#45B7D1"
    },
    "üìß Emails Professionnels": {
        "patterns": [r'@gmail\.com$', r'@yahoo\.com$', r'@hotmail\.com$'],
        "color": "#96CEB4"
    },
    "üìß Emails Entreprise": {
        "patterns": [r'@entreprise\.', r'@soci√©t√©\.', r'@company\.'],
        "color": "#FFEAA7"
    },
    "üåê URLs Sites Web": {
        "patterns": [r'^https?://', r'^www\.'],
        "color": "#DDA0DD"
    },
    "üî¢ Codes Produits": {
        "patterns": [r'^[A-Z]{2,3}\d{3,5}$', r'^PROD\_'],
        "color": "#98D8C8"
    },
    "üë§ Noms Utilisateurs": {
        "patterns": [r'^@[\w\.]+$', r'^user_'],
        "color": "#F7DC6F"
    },
    "üìù Texte G√©n√©rique": {
        "patterns": [r'^[A-Za-z\s]{5,50}$'],
        "color": "#BB8FCE"
    }
}

def classify_item(item):
    """Syst√®me de classification intelligent"""
    item_str = str(item).strip()
    
    for category, rules in CLASSIFICATION_RULES.items():
        for pattern in rules['patterns']:
            if re.search(pattern, item_str, re.IGNORECASE):
                return category, rules['color']
    
    # Classification par d√©faut bas√©e sur le contenu
    if re.match(r'^[\d\+\(\)\s\-]{8,20}$', item_str):
        return "üìû T√©l√©phone G√©n√©rique", "#AAB7B8"
    elif '@' in item_str and '.' in item_str.split('@')[-1]:
        return "üìß Email G√©n√©rique", "#85C1E9"
    elif re.match(r'^https?://', item_str) or re.match(r'^www\.', item_str):
        return "üåê Lien Web", "#F8C471"
    elif len(item_str) <= 10 and item_str.isalnum():
        return "üî§ Code Court", "#D7BDE2"
    else:
        return "üìù Texte Divers", "#F9E79F"

def normalize_phone(phone):
    """Normalisation des num√©ros de t√©l√©phone"""
    if not phone or pd.isna(phone):
        return None
    
    # Nettoyage
    cleaned = re.sub(r'[^\d+]', '', str(phone))
    
    # Conversion international
    if cleaned.startswith('00'):
        cleaned = '+' + cleaned[2:]
    elif cleaned.startswith('0') and len(cleaned) > 6:
        cleaned = '+33' + cleaned[1:]  # France par d√©faut
    
    # Validation
    if re.match(r'^\+?[\d\s\-\(\)]{8,20}$', cleaned):
        return cleaned
    return None

def extract_emails(text):
    """Extraction d'emails"""
    pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
    return re.findall(pattern, str(text))

def analyze_data_quality(items):
    """Analyse de qualit√© des donn√©es"""
    total = len(items)
    if total == 0:
        return {}
    
    stats = {
        'total': total,
        'emails': 0,
        'phones': 0,
        'urls': 0,
        'valid_format': 0,
        'classified': 0
    }
    
    for item in items:
        item_str = str(item).strip()
        
        # D√©tection emails
        if '@' in item_str and '.' in item_str.split('@')[-1]:
            stats['emails'] += 1
        
        # D√©tection t√©l√©phones
        if re.match(r'^[\d\+\(\)\s\-]{8,20}$', item_str):
            stats['phones'] += 1
        
        # D√©tection URLs
        if re.match(r'^(https?://|www\.)', item_str.lower()):
            stats['urls'] += 1
        
        # Format valide
        if len(item_str) >= 3 and len(item_str) <= 100:
            stats['valid_format'] += 1
        
        # Classification
        category, _ = classify_item(item_str)
        if category != "üìù Texte Divers":
            stats['classified'] += 1
    
    # Pourcentages
    for key in ['emails', 'phones', 'urls', 'valid_format', 'classified']:
        stats[f'{key}_pct'] = (stats[key] / total) * 100
    
    return stats

def get_download_link(data, filename):
    """G√©n√©rer lien de t√©l√©chargement"""
    b64 = base64.b64encode(data.encode()).decode()
    return f'<a href="data:file/txt;base64,{b64}" download="{filename}">üì• {filename}</a>'

# INTERFACE PRINCIPALE
def main():
    st.markdown("""
    <div class="main-header">
        <h1 style="margin:0; color:white;">üîÆ LOOPY DIOD PRO</h1>
        <p style="margin:0; opacity:0.9;">Nettoyage & Classification Intelligente</p>
    </div>
    """, unsafe_allow_html=True)

    # Sidebar
    with st.sidebar:
        st.header("‚öôÔ∏è Param√®tres")
        remove_duplicates = st.checkbox("Supprimer doublons", True)
        auto_classify = st.checkbox("Classification auto", True)
        export_by_category = st.checkbox("Exporter par cat√©gorie", True)
        
        st.markdown("---")
        st.header("üìä Classification")
        for category, rules in CLASSIFICATION_RULES.items():
            st.markdown(
                f"<span style='background:{rules['color']}; padding:2px 8px; border-radius:10px; font-size:10px;'>‚óè</span> {category}",
                unsafe_allow_html=True
            )

    # Zone de saisie principale
    col1, col2 = st.columns([2, 1])
    
    with col1:
        input_data = st.text_area(
            "üì• Collez vos donn√©es (1 par ligne):",
            height=300,
            placeholder="Exemple:\n+509 31 45 6642\ncontact@example.com\nhttps://site.com\njohn.doe@entreprise.com\n+33 1 23 45 67 89\nPROD_001\n@username\n001 555 123 4567"
        )

    with col2:
        st.subheader("üéØ Options")
        clean_phones = st.checkbox("Nettoyer t√©l√©phones", True)
        extract_emails_option = st.checkbox("Extraire emails", True)
        remove_empty = st.checkbox("Supprimer vide", True)
        
        st.subheader("üìÅ Import")
        uploaded_file = st.file_uploader("Fichier TXT/CSV", type=['txt', 'csv'])

    # Traitement du fichier upload√©
    if uploaded_file:
        if uploaded_file.type == "text/csv":
            df = pd.read_csv(uploaded_file)
            # Prendre la premi√®re colonne
            input_data = '\n'.join(df.iloc[:, 0].astype(str).tolist())
        else:
            input_data = uploaded_file.getvalue().decode()

    # Bouton de traitement
    if st.button("üîÆ MAGIC CLEAN & CLASSIFY", use_container_width=True):
        if input_data:
            with st.spinner("Traitement en cours..."):
                # Nettoyage initial
                lines = [line.strip() for line in input_data.split('\n')]
                if remove_empty:
                    lines = [line for line in lines if line.strip()]
                
                # Traitement des donn√©es
                processed_data = []
                classification_results = {}
                
                for line in lines:
                    original = line
                    processed = line
                    
                    # Nettoyage t√©l√©phones
                    if clean_phones:
                        phone_cleaned = normalize_phone(line)
                        if phone_cleaned:
                            processed = phone_cleaned
                    
                    # Classification
                    category, color = classify_item(processed)
                    
                    # Stockage r√©sultats
                    processed_data.append({
                        'original': original,
                        'processed': processed,
                        'category': category,
                        'color': color
                    })
                    
                    # Regroupement par cat√©gorie
                    if category not in classification_results:
                        classification_results[category] = []
                    classification_results[category].append(processed)
                
                # Suppression doublons
                if remove_duplicates:
                    seen = set()
                    unique_data = []
                    for item in processed_data:
                        if item['processed'] not in seen:
                            seen.add(item['processed'])
                            unique_data.append(item)
                    processed_data = unique_data
                
                # AFFICHAGE DES R√âSULTATS
                st.success(f"‚úÖ {len(processed_data)} √©l√©ments trait√©s")
                
                # M√©triques
                stats = analyze_data_quality([item['processed'] for item in processed_data])
                
                col1, col2, col3, col4 = st.columns(4)
                with col1:
                    st.metric("Total", len(processed_data))
                with col2:
                    st.metric("Emails", f"{stats.get('emails', 0)}")
                with col3:
                    st.metric("T√©l√©phones", f"{stats.get('phones', 0)}")
                with col4:
                    st.metric("Classifi√©s", f"{stats.get('classified', 0)}")
                
                # R√©sultats par cat√©gorie
                st.subheader("üìä R√©sultats par Cat√©gorie")
                
                for category, items in classification_results.items():
                    category_color = next((rules['color'] for cat, rules in CLASSIFICATION_RULES.items() 
                                         if cat == category), "#CCCCCC")
                    
                    with st.expander(f"üéØ {category} ({len(items)} √©l√©ments)"):
                        # Afficher les √©l√©ments avec badge color√©
                        for item in items:
                            st.markdown(
                                f"<div style='padding:5px; margin:2px; border-left:4px solid {category_color}'>"
                                f"{item}</div>",
                                unsafe_allow_html=True
                            )
                        
                        # Export par cat√©gorie
                        if export_by_category:
                            category_filename = f"loopy_{category.replace(' ', '_').lower()}.txt"
                            category_data = '\n'.join(items)
                            st.markdown(
                                get_download_link(category_data, category_filename),
                                unsafe_allow_html=True
                            )
                
                # Export global
                st.subheader("üíæ Export Global")
                all_processed = [item['processed'] for item in processed_data]
                global_data = '\n'.join(all_processed)
                
                col1, col2 = st.columns(2)
                with col1:
                    st.markdown(get_download_link(global_data, "loopy_tous_√©l√©ments.txt"), unsafe_allow_html=True)
                with col2:
                    # Export avec classification
                    classified_data = "\n".join([
                        f"{item['processed']} | {item['category']}" 
                        for item in processed_data
                    ])
                    st.markdown(get_download_link(classified_data, "loopy_classifi√©.txt"), unsafe_allow_html=True)
                
                # Tableau d√©taill√©
                st.subheader("üìã Vue D√©taill√©e")
                df_results = pd.DataFrame(processed_data)
                st.dataframe(df_results, use_container_width=True)
        
        else:
            st.warning("‚ö†Ô∏è Veuillez coller des donn√©es ou uploader un fichier")

    # Section d'exemples
    with st.expander("üéØ Exemples de Classification"):
        st.write("""
        **Le syst√®me classe automatiquement :**
        - `+509 31 45 6642` ‚Üí üìû T√©l√©phones Ha√Øti
        - `contact@example.com` ‚Üí üìß Emails Professionnels  
        - `https://site.com` ‚Üí üåê URLs Sites Web
        - `PROD_001` ‚Üí üî¢ Codes Produits
        - `@username` ‚Üí üë§ Noms Utilisateurs
        - `+33 1 23 45 67 89` ‚Üí üìû T√©l√©phones France
        """)

if __name__ == "__main__":
    main()